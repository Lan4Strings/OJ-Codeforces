贪心
分析题目，显然b1一定是前i个元素(a[1:i])的和，那b2是之后k个元素(a[i+1:i+k])和，以此类推
所以判断是否有解则可以从左向右扫描元素数组A求和，直到加和为b1（若大于b1则直接输出无解），归零扫描之后，判断b2。。。
因此原问题：[a1,a2...an]->[b1,b2...bm]
可以分解为多个子问题：[a1,a2...ai]->b1;[ai+1,ai+2...ai+k]->b2;...
对于[a1,a2...ai]，因为吃其他怪物会越吃越大，因此最大的一定可以把其他所有怪物吃完（除非所有都是最大的，无法相互吃）
所以找到最大的元素（若多个最大的选择第一个*），吃他左右任意一个（若不能吃则返回无解），然后后面就可以随便吃了

Note:
1*.之所以选择第一个是保证他前面的元素一定都比他小，这样一定可以吃（除非最大的是第一个，那一定不可以吃，因为第二个是和他一样大的）
2.注意边界条件，如果最大的怪物是最后一个或者第一个，注意左右判断会存在变化
3.注意每个怪物的标号，如处理子问题bi时进行输出，他对应的a的编号要加(i-1)(已处理过的子问题) 